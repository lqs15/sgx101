<p>When an enclave is instantiated it provides protection to the data by keeping it within the boundary of the enclave. <strong>Enclave developers should identify enclave data and/or state that is considered secret and potentially needs to be preserved across the following events during which the enclave is destroyed:</strong></p>

<ul>
  <li>
    <p>The application is done with the enclave and closes it.</p>
  </li>
  <li>
    <p>The application itself is closed.</p>
  </li>
  <li>
    <p>The platform is hibernated or shutdown.</p>
  </li>
</ul>

<p>In general, the secrets provisioned to an enclave are lost when the enclave is closed. But if the secret data needs to be preserved during one of these events for future use within an enclave, then it must be stored outside the enclave boundary before closing the enclave. In order to protect and preserve the data, a mechanism is in place which allows enclave software to retrieve <strong>a key unique to that enclave</strong>. This key can only be generated by that enclave on that particular platform. Enclave software uses that key to encrypt data to the platform or to decrypt data already on the platform. SGX refer to these encrypt and decrypt operations as sealing and unsealing, respectively.</p>

<p>There are two options when sealing data or future unsealing conditions (different policies to derive sealing keys from <strong>Root Sealing Key</strong>, which is only known by the enclave):</p>

<h2 id="seal-to-current-enclave">Seal to Current Enclave:</h2>

<p>This method binds the measurement of the current enclave, <code class="highlighter-rouge">MRENCLAVE</code>, to the key used by the sealing operation, using <code class="highlighter-rouge">EGETKEY</code> instruction. Therefore, only an enclave with the same <code class="highlighter-rouge">MRENCLAVE</code> will be able to generate the key to unseal the data. If any attribute related to the enclave has changed, the <code class="highlighter-rouge">MRENCLAVE</code> will also change. As a result, the sealing key will also change and the sealed data cannot be decrypted.</p>

<h2 id="seal-to-the-enclave-author">Seal to the Enclave Author:</h2>

<p>This method binds the identity of the enclave author, which is stored in the enclave’s <code class="highlighter-rouge">MRSIGNER</code> register at initialization time, to the sealing key derived from the Root Sealing Key using <code class="highlighter-rouge">EGETKEY</code> instruction. The Product ID of the enclave is also binded to the derived sealing key. Therefore, only an enclave with the same <code class="highlighter-rouge">MRSIGNER</code> measurement and the same <strong>Product ID</strong> can retrieve the sealing key and unseal the data.</p>

<p>There are two benefits of this mechanism over sealing to the enclave identity. <strong>First</strong>, it allows an enclave to be upgraded by the enclave author without a complex upgrade process to unlock data sealed to the previous version of the enclave and reseal it to the new version. <strong>Second</strong>, it allows enclaves from the same author to share sealed data.</p>

<h1 id="sealing-abstract">Sealing Abstract:</h1>

<p>ISV enclaves are responsible for choosing and implementing the encryption scheme suitable for their needs when sealing their data. That is, SGX does not provide a complete sealing service, but rather a new security primitive (available exclusively for enclaves) based on <code class="highlighter-rouge">EGETKEY</code> features described.</p>

<p>First, allocate memory within the enclave for encrypted data and the sealed data structure which contains both the data to encrypt and additional data, such as application version and enclave information, which participates in the MAC calculation.</p>

<p>Then call the seal data API to perform the sealing operation, which will perform following steps:</p>

<ol>
  <li>
    <p>Verify the input parameters. For example, make sure that the pointer to sealed data structure really points to the buffer inside the enclave.</p>
  </li>
  <li>
    <p>Instantiate and populate a <strong>key request structure</strong> used in the <code class="highlighter-rouge">EGETKEY</code> operation to obtain a seal key:</p>
  </li>
</ol>

<ul>
  <li>Call <code class="highlighter-rouge">EREPORT</code> to obtain the ISV and TCB Security Version Numbers, which will be used in the key derivation</li>
  <li><strong>Key Name:</strong> Identifies the key required, which in this case is the seal key.</li>
  <li><strong>Key Policy:</strong> Use MRSIGNER to seal to the enclave’s author or MRENCLAVE to seal to the current enclave. Reserved bits must be cleared.</li>
  <li><strong>Key ID:</strong> Call RDRAND to obtain a random number for key wear-out protection.</li>
  <li><strong>Attribute Mask:</strong> Bitmask indicating which attributes the seal key should be bound to.</li>
</ul>

<ol>
  <li>
    <p>Call <code class="highlighter-rouge">EGETKEY</code> with the key request structure from the previous step to obtain the seal key.</p>
  </li>
  <li>
    <p>Call the encryption algorithm to perform the seal operation with the seal key. It is recommended to utilize a function that performs <code class="highlighter-rouge">AES-GCM</code> encryption/decryption, such as the <code class="highlighter-rouge">Rijndael128GCM</code>, which is available in the Intel Integrated Performance Primitives Cryptography library.</p>
  </li>
  <li>
    <p><strong>Delete</strong> the seal key from memory to prevent accidental leaks.</p>
  </li>
</ol>

<p>Finally, save the seal data structure (including the key request structure) to external memory for future use within an enclave. The key request structure will be used in future enclave instantiations to obtain the seal key required for the decryption process.</p>

<h1 id="unsealing-abstract">Unsealing Abstract:</h1>

<p>First, allocate memory for the decrypted data.</p>

<p>Then call the unseal API to perform the unsealing operation, which will perform following steps:</p>

<ol>
  <li>
    <p><strong>Verify</strong> input parameters.</p>
  </li>
  <li>
    <p><strong>Retrieve</strong> the key request structure stored together with the seal data structure.</p>
  </li>
  <li>
    <p>Call <strong>EGETKEY</strong> with the <strong>key request structure</strong> to obtain the seal key.</p>
  </li>
  <li>
    <p>Call the <strong>decryption algorithm</strong> to perform the unseal operation using the seal key.</p>
  </li>
  <li>
    <p><strong>Delete</strong> the seal key from memory to prevent accidental leaks.</p>
  </li>
  <li>
    <p><strong>Confirm</strong> that the hash generated by the decryption algorithm matches the one generated during encryption to ensure integrity.</p>
  </li>
</ol>

<p>We use sample code example to explain implementation details. </p>

<hr />

<h2 id="references">References:</h2>

<ol>
  <li>https://eprint.iacr.org/2016/086.pdf</li>
  <li>https://www.idc.ac.il/en/schools/cs/research/Documents/jackson-msc-thesis.pdf</li>
  <li>https://software.intel.com/en-us/articles/innovative-technology-for-cpu-based-attestation-and-sealing</li>
  <li>https://software.intel.com/en-us/blogs/2016/05/04/introduction-to-intel-sgx-sealing</li>
  <li>https://insujang.github.io/2017-10-09/intel-sgx-sealing/</li>
  <li>https://software.intel.com/en-us/node/702997</li>
</ol>
