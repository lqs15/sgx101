<!DOCTYPE html>
<html lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta http-equiv="content-type" content="text/html; charset=utf-8" />

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1" />

  <title>
    
      Attestation &middot; SGX 101
    
  </title>

  


  <!-- CSS -->
  <link rel="stylesheet" href="/sgx101/assets/css/main.css" />
  

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Abril+Fatface" />

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/sgx101/favicon.png" />
<link rel="shortcut icon" href="/sgx101/favicon.ico" />

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/feed.xml" />

  <!-- Additional head bits without overriding original head -->
</head>


  <body class="page">

    <div id="sidebar">
  <header>
    <div class="site-title">
      <a href="/sgx101/">
        
          <span class="back-arrow icon"><svg fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
  <path d="M0 0h24v24H0z" fill="none"/>
  <path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z"/>
</svg></span>
        
        SGX 101
      </a>
    </div>
    <p class="lead">The very first place to study Intel SGX.</p>
  </header>
  <nav id="sidebar-nav-links">
  
    <a class="home-link "
        href="/sgx101/">Home</a>
  
  

  

  


  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
      <a class="page-link "
          href="/sgx101/sslab.html">SSLab</a>
    
  

  
    
      <a class="page-link "
          href="/sgx101/bootstrap.html">SGX Bootstrap</a>
    
  

  
    
      <a class="page-link "
          href="/sgx101/resources.html">Resources</a>
    
  

  
    
      <a class="page-link "
          href="/sgx101/about.html">About Us</a>
    
  


  


  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  

  
    
  


  <!-- Optional additional links to insert in sidebar nav -->
</nav>


  

  <nav id="sidebar-icon-links">
  

  <a id="subscribe-link"
     class="icon" title="Subscribe" aria-label="Subscribe"
     href="/sgx101/feed.xml">
    <svg fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
    <path d="M0 0h24v24H0z" fill="none"/>
    <circle cx="6.18" cy="17.82" r="2.18"/>
    <path d="M4 4.44v2.83c7.03 0 12.73 5.7 12.73 12.73h2.83c0-8.59-6.97-15.56-15.56-15.56zm0 5.66v2.83c3.9 0 7.07 3.17 7.07 7.07h2.83c0-5.47-4.43-9.9-9.9-9.9z"/>
</svg>
  </a>

  
  
  
  

  
    <a id="tags-link"
       class="icon"
       title="Tags" aria-label="Tags"
       href="/sgx101/tags.html">
      <svg fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
    <path d="M0 0h24v24H0z" fill="none"/>
    <path d="M17.63 5.84C17.27 5.33 16.67 5 16 5L5 5.01C3.9 5.01 3 5.9 3 7v10c0 1.1.9 1.99 2 1.99L16 19c.67 0 1.27-.33 1.63-.84L22 12l-4.37-6.16z"/>
</svg>
    </a>
  

  
    <a id="search-link"
       class="icon"
       title="Search" aria-label="Search"
       href="/sgx101/search.html">
      <svg fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
    <path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/>
    <path d="M0 0h24v24H0z" fill="none"/>
</svg>
    </a>
  

  <!-- Optional additional links to insert for icons links -->
</nav>

  <p>
  &copy; 2018.
  <a href="https://gts3.org/">SSLab.</a>
</p>

</div>

    <main class="container">
      <header>
  <h1 class="page-title">Attestation</h1>
</header>
<div class="content">
  <p>Sometimes enclaves need to collaborate with other enclaves on the same platform due to different reasons such as data exchange if the enclave is too small to hold all the information, or communication with Intel reserved enclaves to conduct specific Intel services.</p>

<p>Therefore, the two exchanging enclaves have to prove to each other that they can be trusted. In other scenarios when an SGX enabled ISV client requests secrets from its ISV client, password management service for example, the client have to prove to the server that the client application is running on a trusted platform that can process the secrets securely. Both of those two conditions require a proof of secured execution environment, and Intel SGX refers to this proving process as attestation.</p>

<p>There are two types of attestation with respect to the two above mentioned scenarios: <strong>Local Attestation</strong> and <strong>Remote Attestation</strong>.</p>

<p>The successful result of local attestation provides an authenticated assertion between two enclaves running on the same platform that they can trust each other and exchange information safely, while remote attestation provides this kind of verification for the ISV client to the server so that ISV server can confidently provides the client with the secrets it requested.</p>

<p>Before diving into the details of attestation, we need to clarify some required instructions and data.</p>

<hr />

<h2 id="device-root-keys">Device Root Keys</h2>

<p>There are two device root keys that are fused to SGX CPU at production.</p>

<h3 id="root-provisioning-key-rpk">Root Provisioning Key (RPK)</h3>

<p>This key is randomly generated on a dedicated Hardware Security Module (HSM) within a special purpose facility called Intel Key Generation Facility (iKGF) which is guaranteed to be a well-guarded offline production facility. Intel is also responsible for maintaining a database of all keys ever produced by the HSM. RPKs are delivered out to different factory facilities, named by Intel’s formal publications as the “high volume manufacturing system”, to be integrated into processors’ fuses.</p>

<p>Intel stores all RPKs as they are the basis of how SGX processors demonstrate their genuineness through an online provisioning protocol. For this reason, the iKGF also forwards different derivations of each RPK to Intel’s online servers.</p>

<h3 id="root-sealing-key-rsk">Root Sealing Key (RSK)</h3>

<p>This key is randomly generated automatically inside the CPU during production to be statistically different from part to part. Intel declares that it attempts to erase all production lines residues of this key so that each platform should assume that its RSK value is both unique and known only to itself. Most of the keys provided by enclave’s trusted interface base their derivation on platform’s RSK so that no other parties can known the keys.</p>

<p><img src="/sgx101/assets/pics/attestation.png" alt="attestation" /></p>

<h2 id="enclave-measurement-aka-software-tcb">Enclave Measurement (aka Software TCB):</h2>

<h4 id="when-an-enclave-is-built-and-initialized-intel-sgx-will-generate-a-cryptographic-log-of-all-the-build-activities-including">When an enclave is built and initialized, Intel SGX will generate a cryptographic log of all the build activities, including:</h4>

<ul>
  <li>Content: code, data, stack, heap</li>
  <li>Location of each page within the enclave</li>
  <li>Security flags being used</li>
</ul>

<p>The “Enclave Identity”, which is a 256-bit hash digest of the log, is stored as MRENCLAVE as the enclave’s software TCB. In order to verify the software TCB, one should first securely obtain the enclave’s software TCB, then securely obtain the expected enclave’s software TCB and compare those two values.</p>

<h2 id="two-user-instructions">Two user instructions:</h2>

<h3 id="reportcontains-following-data">REPORT Contains following data:</h3>

<ul>
  <li>Measurement of the code and data in the enclave.</li>
  <li>A hash of the public key in the ISV certificate presented at enclave initialization time.</li>
  <li>User data.</li>
  <li>Other security related state information (not described here).</li>
  <li>A signature block over the above data, which can be verified by the same platform that produced the report.</li>
</ul>

<h3 id="ereport"><code class="highlighter-rouge">EREPORT</code></h3>

<p>This instruction generates a cryptographic structure, called REPORT, that binds <code class="highlighter-rouge">MRENCLAVE</code> to the target enclave’s REPORT KEY.</p>

<h3 id="report-key">REPORT KEY</h3>

<p>Used by EREPORT to sign all reports generated on that specific platform and destined that for that enclave.</p>

<h3 id="egetkey"><code class="highlighter-rouge">EGETKEY</code></h3>

<p>Enclaves can use EGETKEY instruction to get derivatives of device keys. <code class="highlighter-rouge">EGETKEY</code> produces symmetric keys for different purposes depending on invoking enclave attributes and the requested key type. There are five different key types. Two are sealing and report keys available for all enclave. The rest are limited only to SGX architectural enclaves.</p>

<p><code class="highlighter-rouge">EGETKEY</code> uses Security Version Number (SVN) specified by the requesting enclave to define requested key characteristics. CPU SVN to reflect processor microcode version, or ISV SVN to reflect enclave software version. <code class="highlighter-rouge">EGETKEY</code> checks these values against those stored in <code class="highlighter-rouge">SIGSTRUCT</code> and only allows to obtain keys with SVN values lower or equal to those of the invoking enclave so that upgraded versions of the same software can retrieve keys created by former versions.</p>

<h3 id="sigstruct">SIGSTRUCT</h3>

<p>Enclaves’ certificate is called <code class="highlighter-rouge">SIGSTRUCT</code> and is a mandatory supplement for launching any enclave. The <code class="highlighter-rouge">SIGSTRUCT</code> holds enclave’s <code class="highlighter-rouge">MRENCLAVE</code> together with other enclave attributes. <code class="highlighter-rouge">SIGSTRUCT</code>s are signed by the ISV with its private key, which was originally signed by an SGX launch authority. Intel is considered the primary enclave launch authority, however other entities can be trusted by the platform owner to authorize launching of enclaves. The respected launch authority is specified by its public key hash signed by Intel and stored on the platform.</p>

<p>We start with clarifying the process of local attestation and then remote attestation.</p>

<hr />

<h2 id="local-attestation">Local Attestation</h2>

<p>Before multiple enclaves collaborate with each other on the same platform, one enclave will have to authenticate the other locally using Intel SGX Report mechanism to verify that the counterpart is running on the same TCB platform by applying the <code class="highlighter-rouge">REPORT</code> based Diffie-Hellman Key Exchange. This procedure is referred as local attestation by Intel. The successful result of local attestation will offer a protected channel between two local enclaves with guarantee of confidentiality, integrity and replay protection.</p>

<h3 id="local-attestation-abstract">Local Attestation Abstract:</h3>

<p><img src="/sgx101/assets/pics/local_attestation.png" alt="local attestation" /></p>

<ol>
  <li>
    <p>There are two enclaves on the same platform, referred to as Enclave A and Enclave B. We assume they have established a communication path between each other, and the path doesn’t need to be trusted. W.l.o.g we assume B is asking A to prove it’s running on the same platform as B.</p>
  </li>
  <li>
    <p>First, B retrieves its <code class="highlighter-rouge">MRENCLAVE</code> value and sends it to A via the untrusted channel.</p>
  </li>
  <li>
    <p>A uses <code class="highlighter-rouge">EREPORT</code> instruction to produce a report for B using B’s <code class="highlighter-rouge">MRENCLAVE</code>. Then A sends this report back to B. A can also include Diffie-Hellman Key Exchange data in the <code class="highlighter-rouge">REPORT</code> as user data for trusted channel creation in the future.</p>
  </li>
  <li>
    <p>After B receives the <code class="highlighter-rouge">REPORT</code> from A, B calls <code class="highlighter-rouge">EGETKEY</code> instruction to get <code class="highlighter-rouge">REPORT</code> KEY to verify the <code class="highlighter-rouge">REPORT</code>. If the <code class="highlighter-rouge">REPORT</code> can be verified with the REPORT KEY, then B assures that A is on the same platform as B because the REPORT KEY is specific to the platform.</p>
  </li>
  <li>
    <p>Then B use the <code class="highlighter-rouge">MRENCLAVE</code> received from A’s <code class="highlighter-rouge">REPORT</code> to create another <code class="highlighter-rouge">REPORT</code> for A and sends the <code class="highlighter-rouge">REPORT</code> to A.</p>
  </li>
  <li>
    <p>A then also can do the same as step 4 to verity B is on the same platform as A.</p>
  </li>
  <li>
    <p>By utilizing the user data field of the <code class="highlighter-rouge">REPORT</code>, A and B can create a secure channel using Diffie-Hellman Key Exchange. Information exchange can be encrypted by the shared symmetric key.</p>
  </li>
</ol>

<hr />

<h2 id="remote-attestation-primitives">Remote Attestation Primitives</h2>

<p>This section introduces the design details of the remote attestation service provided by Intel.</p>

<h3 id="overall-view-of-intel-sgx-infrastructure-services">Overall View of Intel SGX Infrastructure Services</h3>

<p><img src="/sgx101/assets/pics/ias.png" alt="IAS" /></p>

<h3 id="platform-provisioning">Platform Provisioning</h3>

<p>In order to transform a local REPORT into a remotely verifiable <code class="highlighter-rouge">QUOTE</code>, Quoting Enclave uses a platform unique asymmetric attestation key. The <code class="highlighter-rouge">QUOTE</code> can then be verified by a remote party using the corresponding public key.</p>

<p>So how does QE obtain this attestation key in the first place? In this tutorial we explain the provisioning process in which an SGX platform receives its remote attestation key.</p>

<p>Provisioning is the process by which an SGX device demonstrates to Intel its authenticity as well as its CPU SVN and other system components attributes, in order to receive an appropriate attestation key reflecting its SGX genuinely and TCB version. Normally, provisioning is done during platform initial setup phase, but re-provisioning can also be performed after purchase due to update to crucial system components such as firmware, BIOS or microcodes due to vulnerabilities. In such cases, the attestation key may be replaced to reflect platform renewed TCB security level.</p>

<p>Attestation key is the core asset in the SGX ecosystem. Relying parties trust valid attestation signatures as an Intel signed certificate that guarantees the platform’s authenticity. In order to facilitate SGX provisioning services, Intel operates a dedicated online provisioning infrastructure. SGX provisioning and remote attestation protocol follows a group signature scheme developed by Intel called Enhanced Privacy ID (EPID). To implement the EPID provisioning process Intel provides an architectural enclave called the Provisioning Enclave (PvE).</p>

<h3 id="provisioning-enclave-pve">Provisioning Enclave (PvE)</h3>

<p>The PvE is responsible for conducting the provisioning process on the platform against Intel’s online provisioning servers. In this process PvE demonstrates that is has a key that Intel put in a real SGX processor and in return, is provisioned with a unique platform attestation for future remote attestations. Both sides implement the EPID scheme join protocol; the PvE functions as a new joining member and Intel as the group membership issuer that issues new group membership credentials.</p>

<p>PvE proves its authenticity by using several SGX privileged key types which are accessible through EGETKEY instruction only by SGX architectural enclaves. Two of those keys are Provisioning Key (PK) and Provisioning Seal Key (PSK). The uniqueness of PvE and QE is based on their SIGSTRUCT certificates signed by Intel (MRSIGNER). Those enclaves are thus authorized to launch with privileged attributes in order to later obtain special keys by executing EGETKEY instruction.</p>

<p>Two phases are involved in the derivation process of PK. First, bind Root Provisioning Key to HW TCB. TCB key occurs during processors boot time by looping over PRF with the current platform SVN patch level which reflects platform’s firmware components. Second, add SW properties to the resulting PK. It occurs when EGETKEY is called and uses the TCB key as basis for derivation. PvE’s software elements are reflected by EGETKEY input parameters. Root Signing Key and Owner Epoch value are ignored in this case to render the same platform-specific key regardless of its current owner. The resulting PK is then a unique key that reflects both HW and SW components of the SGX platform. This process also minimizes the exposure of Root Provisioning Key.</p>

<h3 id="provisioning-protocol">Provisioning Protocol</h3>

<p>After getting the PK, the platform can start the provisioning process to get the attestation key.</p>

<h4 id="1-enclave-hello">1. Enclave Hello</h4>

<p>Once we have TCB specific PK, PvE generates two values to initiate the provisioning protocol. The first is a hash of the PK called Platform Provisioning ID (PPID). The second reflects the claimed TCB level based on current SVN. Both encrypted using IPS’s public key and sent to IPS.</p>

<h4 id="2-server-challenge">2. Server Challenge</h4>

<p>Intel uses PPID to determine whether the platform has been previously provisioned. If so, an encrypted version of a previously generated attestation key is added to the server’s challenge. If not, the server determines the EPID group for that platform, and adds the EPID group parameters together with a liveliness nonce and a pre-computed TCB challenge to the message sent back to the platform.</p>

<p>Since all RPKs are stored by the offline Intel Key Generation Facility (iKGF), it can perform the same hardware and software TCB specific derivation process as performed by the PvE using EGETKEY (how to get SW attributes?) on every SGX device to produce its own provisioning key (how to know which SGX is which?). This PK is used to encrypt a random value to generate a platform specific TCB challenge. All pre-computed challenges are sent to Intel’s online servers to support the provisioning protocol.</p>

<h4 id="3-enclave-response">3. Enclave Response</h4>

<p>After PvE decrypts the TCB challenge with its PK, it uses it to generate a TCB proof by using the TCB challenge as a key to CMAC the nonce received from Intel. Next, PvE generates a random EPID membership key and hides it mathematically according to EPID protocol so that IPS cannot learn the membership key.</p>

<p>To facilitate future attestation key retrieval service, the non-hidden membership key is encrypted by PvE using another special key, PSK. PSK derivation does not include the Owner Epoch and uses RSK as the root key for derivation. The PSK thus is not affected by the platform changing owners, and is exclusive to that specific platform.</p>

<p>If the platform has been formerly provisioned and the ongoing protocol is an attestation key retrieval or TCB update, the platform has to prove that it has never been revoked in the past. This is achieved by using PSK to decrypt the backed up attestation key copies obtained from the server, and using them to sign a selected message chosen by Intel.</p>

<p>Both the hidden and the encrypted EPID membership keys are sent, together with the TCB and non-revoked proofs.</p>

<h4 id="4-completion">4. Completion</h4>

<p>After receiving the response, IPS first validates the TCB proof using the value received from iKGF and continues the EPID Join protocol on success. The hidden membership key is processed to create a unique certificate signed with the EPID group issuer key and stored together with the encrypted membership key for future re-provisioning events. The final message completing the protocol is then sent by the server containing the signed certificate.</p>

<p>Platform’s membership key together with the matching signed certificate form a unique EPID private key. Since the attestation key is constructed collaboratively by both parties, no one can forge a valid membership signature produced by the platform.</p>

<h4 id="5-final">5. Final</h4>

<p>PvE encrypts the attestation key with PSK and stores on the platform for future use. Since EPID groups are categorized according to TCB levels, EPID signature can thus be user to represent both platform’s SGX genuineness and its TCB level.</p>

<hr />

<h2 id="remote-attestation-process">Remote Attestation Process</h2>

<p>Generally speaking, the goal of Remote Attestation is for a Hardware entity or a combination of Hardware and Software to gain the trust of a remote service provider, such that the service provider can confidently provide the client with the secrets requested. With Intel SGX, Remote Attestation software includes the application’s enclave, and the Intel-provided Quoting Enclave (QE) and Provisioning Enclave (PvE). The attestation Hardware is the Intel SGX enabled CPU. Remote attestation provides verification for three things: the application’s identity, its intactness (that it has not been tampered with), and that it is running securely within an enclave on an Intel SGX enabled platform.</p>

<h3 id="sigma-protocol">Sigma protocol</h3>

<p>Sigma is a protocol that includes a <strong>Diffie-Hellman key exchange</strong>, but also addresses the weaknesses of DH. The protocol Intel SGX uses differs from the regular Sigma protocol in that the Intel SGX platform uses Intel EPID to authenticate while the service provider uses Public Key Infrastructure (in regular Sigma, both parties use PKI). Finally, the Key Exchange libraries require the service provider to use an ECDSA, not an RSA, key pair in the authentication portion of the protocol and the libraries use ECDH for the actual key exchange.</p>

<p>As a result of this exchange between the client and the service provider, a shared key between the enclave and the challenger is produced that can be used for encrypting secrets that are to be provisioned in the enclave. Once inside the enclave, these secrets could then be decrypted by the application.</p>

<h3 id="diffie-hellman-key-exchange-dhke">Diffie-Hellman Key Exchange (DHKE)</h3>

<p>A method for exchanging keys over a public channel without leaking the actual key to other listeners. The cryptographic algorithm is explained here.</p>

<h3 id="intel-enhanced-privacy-id-epid">Intel Enhanced Privacy ID (EPID)</h3>

<p>It is an extension to an existing Direct Anonymous Attestation (DAA) scheme with some additions, for example the use of SigRL (Signature Revocation List). EPID enables signing objects without leaving a trace that can be uniquely backtracked to the signer, making the signing process anonymous. This is done by dividing signers to groups (also known as EPID groups), based on their processor type. This way they create signatures with their own secret keys, but the signatures can be verified only with the public key of the group they belong to, making it possible to check that the signer belongs to the right group, but impossible to uniquely identify the signer.</p>

<h3 id="revocation-lists">Revocation Lists</h3>

<p>SGX facilitates three types of Revocation Lists (RLs): Group-RL which holds all revoked EPID groups, Priv-RL listing all revoked private-keys of the same EPID group, and Sig-RL that lists tuples of a basename and its corresponding signature of all revoked members in the same EPID group.</p>

<h3 id="trusted-computing-base-tcb">Trusted Computing Base (TCB)</h3>

<p>An entity responsible for protecting the secret provisioned to the enclave (both software and hardware).</p>

<h3 id="quoting-enclave-qe">Quoting Enclave (QE)</h3>

<p>A special enclave on every SQX processor and is tasked entirely with handling the remote attestation. It receives REPORTs from other enclaves, verifies them and signs them with the attestation key before returning the result, also known as a QUOTE, to the application.</p>

<h3 id="sgx-service-providers">SGX Service Providers</h3>

<p>Relying parties are referred to as service providers and do not have to hold SGX enabled hardware. Service providers are expected to register to the IAS and meet a set of Intel defined requirements in order to submit attestation evidence for IAS verification. This registration binds service providers’ Transport Layer Security (TLS) certificate to a unique Service Provider ID (SPID), and permits access to the IAS services. Some of these main IAS services are: verifying ISV enclave Quotes, requesting updated attestation revocation lists and retrieving the assertion information history associated with a Quote.</p>

<h3 id="remote-attestation-modes">Remote Attestation Modes</h3>

<p>The QE supports two Quote signature modes with different link-ability properties, Fully-anonymous and Pseudonymous Quotes. The link-ability property of a Quote is determined by a basename parameter signed using platform’s unique attestation key. Using the same attestation key to sign the same basename parameter multiple times yields pseudonymous Quotes that are easily linkable. This mode is used by service providers to keep track of revisiting users and protect against sybil attacks, while preserving user’s privacy. When a pseudonymous Quote is used, the IAS first validates that the basename used is associated to that specific service provider. This role of the IAS enforces user’s pseudonymous separation between different service providers. In contrast, by signing multiple signatures on different basenames, it is computationally infeasible to determine whether the Quotes were produced using the same attestation key or not, thus preserving platform’s anonymity. Therefore random basenames are used by the QE to sign Fully-anonymous Quotes.</p>

<h3 id="remote-attestation-abstract">Remote Attestation Abstract</h3>

<p><img src="/sgx101/assets/pics/ra.png" alt="RA" /></p>

<p>For remote attestation, both symmetric and asymmetric key systems are used. The symmetric key system is used in local attestation with only the quoting enclave and the EREPORT instruction having access to the authentication key. Asymmetric key system is used for creating an attestation that can be verified from other platforms. The attestation key itself is asymmetric (EPID keys).</p>

<h4 id="there-are-mainly-three-platforms-involved-in-remote-attestation">There are mainly three platforms involved in Remote Attestation:</h4>

<ul>
  <li>The service provide (challenger)</li>
  <li>The application with its enclave and its QE</li>
  <li>Intel Attestation Service (IAS) that verifies the enclave
Stages</li>
</ul>

<h3 id="detailed-stages">Detailed Stages</h3>

<ol>
  <li>
    <p>At first, the ISV enclave sends out an initial request to the remote service provider, which includes the <strong>EPID group</strong> the platform claims to currently be a member of.</p>
  </li>
  <li>
    <p>If the service provider wishes to serve members of the claimed group, it may proceed by requesting an updated <strong>SigRL</strong> from the IAS.</p>
  </li>
  <li>
    <p>he service provider then constructs a <strong>challenge message</strong> that consists its SPID, a liveliness random nonce, the updated SigRL and an optional basename parameter (if a pseudonym signature is required).</p>
  </li>
  <li>
    <p>If the enclave supports the requested signature mode, it invokes the <code class="highlighter-rouge">EREPORT</code> instruction to create a locally verifiable report addressed to platform’s QE. In order to establish an authenticated secure channel between the enclave and the service provider, a <strong>freshly generated ephemeral public key</strong> may be added to the report’s user data field. The report and SP’s challenge are sent to QE.</p>
  </li>
  <li>
    <p><em>(Local Attestation happens here)</em> The QE calls <code class="highlighter-rouge">EGETKEY</code> to obtain the <code class="highlighter-rouge">REPORT KEY</code> and verifies the report. If successful, QE calls <code class="highlighter-rouge">EGETKEY</code> again to receive platform’s Provisioning Seal Key to decrypt platform’s remote attestation key (EPID private key). The attestation key is first used to produce an identity signature by either signing the challenged basename or a random value, according to the attestation mode requested.</p>
  </li>
  <li>
    <p>The attestation key is then used to compute two signatures of knowledge over the platform’s identity signature <code class="highlighter-rouge">MRENCLAVE</code>. <strong>The first</strong> proves the identity signature was signed with a key certified by Intel. <strong>The second</strong> is a non-revoked proof that proves the key used for the identity signature does not create any of the identity signatures listed in the challenged SigRL. A final <code class="highlighter-rouge">QUOTE</code> is then generated and encrypted using IAS’s public key, which is hardcoded in QE, and the result is sent back to the attesting enclave. The <code class="highlighter-rouge">QUOTE</code> holds the identity of the attesting enclave, execution mode details (e.g. SVN level) and additional data.</p>
  </li>
  <li>
    <p>The enclave then forwards the <code class="highlighter-rouge">QUOTE</code> to the <strong>SP</strong> for verification.</p>
  </li>
  <li>
    <p>Since the <code class="highlighter-rouge">QUOTE</code> is encrypted, it is verifiable exclusively by Intel. Hence, the service provider simply forwards the <code class="highlighter-rouge">QUOTE</code> to the <strong>IAS</strong> for verification.</p>
  </li>
  <li>
    <p>The <strong>IAS</strong> examines the <code class="highlighter-rouge">QUOTE</code> by first validating its EPID proofs against its identity signature. It then verifies the platform is not listed on the group <strong>Priv-RL</strong> by computing an identity signature on the <code class="highlighter-rouge">QUOTE</code> basename for each private key in the list, and verifying that none of them equals the QUOTE’s identity signature. This finalizes the validity check of the platform, and the IAS then creates a new attestation <strong>verification report</strong> as a response to the SP. The Attestation Verification Report includes the QUOTE structure generated by the platform for the attesting enclave.</p>
  </li>
  <li>
    <p>A <strong>positive</strong> Attestation Verification Report confirms the enclave as running a particular piece of code on a genuine intel SGX processor. It is then the responsibility of the SP to validate the ISV enclave identity and serve an appropriate response back to the platform.</p>
  </li>
</ol>

<hr />

<h2 id="remote-attestation-example">Remote Attestation Example</h2>

<p>Remote Attestation code example is available <a href="https://github.com/sangfansh">here</a></p>

<p>Original unmodified version is available <a href="https://github.com/svartkanin/linux-sgx-remoteattestation">here</a></p>

<p>IAS Service Guide is available <a href="https://software.intel.com/sites/default/files/managed/7e/3b/ias-api-spec.pdf">here</a></p>

<h3 id="before-running-the-code-some-settings-have-to-be-set-in-the-generalsettingsh-file">Before running the code, some settings have to be set in the GeneralSettings.h file:</h3>

<ul>
  <li>
    <p>The application port and IP</p>
  </li>
  <li>
    <p>A server certificate and private key are required for the SSL communication between the SP and the Application (which can be self-signed)</p>
  </li>
</ul>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>openssl req <span class="nt">-x509</span> <span class="nt">-nodes</span> <span class="nt">-newkey</span> rsa:4096 <span class="nt">-keyout</span> server.key <span class="nt">-out</span> server.crt <span class="nt">-days</span> 365
</code></pre></div></div>

<ul>
  <li>
    <p>The SPID provided by Intel when registering for the developer account</p>
  </li>
  <li>
    <p>The certificate sent to Intel when registering for the developer account</p>
  </li>
  <li>
    <p>IAS Rest API url (should stay the same)</p>
  </li>
</ul>

<h3 id="to-be-able-to-run-the-above-code-some-external-libraries-are-needed">To be able to run the above code some external libraries are needed:</h3>

<ul>
  <li>Google Protocol Buffers (should already be installed with the SGX SDK package) otherwise install</li>
</ul>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>libprotobuf-dev libprotobuf-c0-dev protobuf-compiler
</code></pre></div></div>

<p><strong>All other required libraries</strong> can be installed with the following command:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>apt-get <span class="nb">install </span>libboost-thread-dev libboost-system-dev curl libcurl4-openssl-dev libssl-dev liblog4cpp5-dev libjsoncpp-dev
</code></pre></div></div>

<p>After the installation of those dependencies, the code can be compiled with the following commands:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cd </span>ServiceProvider
make
<span class="nb">cd</span> ../Application
make <span class="nv">SGX_MODE</span><span class="o">=</span>HW <span class="nv">SGX_PRERELEASE</span><span class="o">=</span>1
</code></pre></div></div>

<p>The sample application has two parts: <strong>ServiceProvider</strong> and the <strong>Application</strong>. The Application needs to prove to the ServiceProvider that it is running on a claimed trusted SGX enclave so that the Service Provider can proceed to provision secret data. The messages exchanged during the remote attestation process are serialized using <a href="https://github.com/google/protobuf">Google Protobuf</a>.</p>

<p>First let’s examine the <strong>Application</strong>. The entry point of the Application is inside isv_app.cpp (ISV stands for Individual Software Vendor). It starts by initiating the <code class="highlighter-rouge">MessageHandler</code> that handles the messages to be exchanged during remote attestation.</p>

<script src="https://gist.github.com/sangfansh/e884ede5fd80082eeedc70f22e8f2e4c.js"></script>

<h3 id="messagehandler-a-wrapper-of-all-of-the-networking-functionalities">MessageHandler (a wrapper of all of the networking functionalities):</h3>

<p>The MessageHandler has a protected enclave that handles all the secrets, as well as the generation and processing of cryptographic messages. We can see that MessageHandler has several message generation and handling functions. Specifically they are functions in forms of <code class="highlighter-rouge">generateMsgx()</code> and <code class="highlighter-rouge">handleMsgx()</code>. Google Protobuf is used by those functions to serialize the messages to be exchanged via network transportation.</p>

<p>The MessageHandler also has a <code class="highlighter-rouge">NetworkManagerServer</code> object. The NetworkManagerServer object enables the Application to act as a server to initialize connection and binds itself to a client via SSL (implementation detail in server.h, using object Server* server). It also inherits <code class="highlighter-rouge">NetworkManager</code> class in order to serialize and send messages.</p>

<script src="https://gist.github.com/sangfansh/9e159a13dc47ed196facd14a9a2e148a.js"></script>

<p><code class="highlighter-rouge">msg -&gt; init():</code>
<script src="https://gist.github.com/sangfansh/788651555f6e7e43ceb8dd346764da4f.js"></script>
<script src="https://gist.github.com/sangfansh/13a82a3b4e7b5c51bfe67b7bf97cd542.js"></script>
<script src="https://gist.github.com/sangfansh/60737cb869a669cc45f1b1960347c220.js"></script></p>

<p>When the <code class="highlighter-rouge">MessageHandler</code> msg is initialized using <code class="highlighter-rouge">init()</code>, the <code class="highlighter-rouge">NetworkManagerServer</code> object inside is also initialized. It causes the initialization of <code class="highlighter-rouge">Server</code> object, which sets up the SSL io_service socket and the selected port. Then a function <code class="highlighter-rouge">incomingHandler()</code> is connected to the <code class="highlighter-rouge">NetworkManagerServer</code> as the <code class="highlighter-rouge">CallbackHandler</code>. This function is responsible for generating all the message replies according to the type of the message that it receives.</p>

<p>As mentioned above, <code class="highlighter-rouge">incomingHandler(string, int)</code> handles all of the incoming messages and generates corresponding replies. Let’s briefly examine this handler (line 395 at <code class="highlighter-rouge">MessageHandler.cpp</code>).</p>

<script src="https://gist.github.com/sangfansh/bda856ff5728ab7fff00172e6b98d456.js"></script>

<h3 id="there-are-four-cases">There are four cases:</h3>

<ul>
  <li>RA_VERIFICATION</li>
  <li>RA_MSG0</li>
  <li>RA_MSG2</li>
  <li>RA_ATT_RESULT</li>
</ul>

<p>Each case is one type of the messages that are exchanged in time order during remote attestation.</p>

<p>Upon here, the ISV application’s MessageHandler has finished initialization.</p>

<p><code class="highlighter-rouge">msg -&gt; start():</code>
<script src="https://gist.github.com/sangfansh/ec0b603dc914421b58c4454f3e3ef126.js"></script>
<script src="https://gist.github.com/sangfansh/4004e50e2bc242b5653fd6ea7dfad4a3.js"></script></p>

<p>Function <code class="highlighter-rouge">start()</code> calls NetworkManager’s <code class="highlighter-rouge">startService()</code> function, which calls Server’s <code class="highlighter-rouge">start_accept()</code> to start SSL service. Upton here, the ISV has started running and is ready for any incoming traffic.</p>

<h3 id="now-lets-examine-serviceproviders-structure-and-initialization-process">Now let’s examine <code class="highlighter-rouge">ServiceProvider</code>’s structure and initialization process.</h3>

<p><code class="highlighter-rouge">isv_app.cpp</code> inside <code class="highlighter-rouge">ServiceProvider</code>:
<script src="https://gist.github.com/sangfansh/2dbd162c0dc46c51d0f046f0fbc8b7ed.js"></script></p>

<p>It’s the ServiceProvider Application itself. Similar to the client’s application, it has its own message handler <code class="highlighter-rouge">VerificationManager</code> since it acts as the verifier in the remote attestation process.</p>

<p>Inside the VerificationManager, it has a <code class="highlighter-rouge">NetworkManagerClient</code> which also inherits <code class="highlighter-rouge">NetworkManager</code> and is responsible for the SSL connection as well as serializing and sending messages.</p>

<script src="https://gist.github.com/sangfansh/d1c1443a08f7e7128fff3203379a4231.js"></script>

<p>In addition, it has a <code class="highlighter-rouge">WebService</code> object to performs the verification phase with <strong>Intel Attestation Service (IAS)</strong> using the <code class="highlighter-rouge">QUOTE</code> sent from the client enclave. In one word, a <code class="highlighter-rouge">ServicePrivider</code> also acts as a wrapper of all the IAS requests and message processing, as well as any encryption key derivation, using <code class="highlighter-rouge">WebService</code>.</p>

<script src="https://gist.github.com/sangfansh/dfa4b517e17cbc9030d0f09326b28698.js"></script>

<p><code class="highlighter-rouge">vm -&gt; init()</code>:
<script src="https://gist.github.com/sangfansh/f935847f93926df81b4f4b7c1bace686.js"></script></p>

<p>First, dynamically allocate a new <code class="highlighter-rouge">ServiceProvider</code> to ensure freshness of secret. Then the function initializes <code class="highlighter-rouge">NetworkManagerClient</code> that will connect to the Server (the Application) using SSL. Finally, a <code class="highlighter-rouge">CallBackHandler</code> similar to the one of the Application is set up. The handler itself is the function <code class="highlighter-rouge">incomingHandler(string, int)</code> inside <code class="highlighter-rouge">VerificationManager</code> that will handle incoming messages coming from the Application during remote attestation (line 132 at <code class="highlighter-rouge">VerificationManager.cpp</code>).</p>

<script src="https://gist.github.com/sangfansh/eadaa5c6e6d10fe43e3a562c8efd7f4f.js"></script>

<h3 id="there-are-also-four-cases-of-handling-messages">There are also four cases of handling messages:</h3>

<ul>
  <li>RA_MSG0</li>
  <li>RA_MSG1</li>
  <li>RA_MSG3</li>
  <li>RA_APP_ATT_OK</li>
</ul>

<p>Notice that at the end of the handler, it initializes the message stream with a <code class="highlighter-rouge">RA_VERIFICATION</code> type string and the actual <code class="highlighter-rouge">REQUEST</code>. By doing so right after SSL handshake, the ServiceProvider can immediately start the RA process by forwarding the remote attestation request to the Application.</p>

<p><code class="highlighter-rouge">vm -&gt; start()</code>:
<script src="https://gist.github.com/sangfansh/dbee6d345177c73d1ca2c1914aa5da3c.js"></script>
<script src="https://gist.github.com/sangfansh/6969fb1cf21cdcd19e496a81a909947a.js"></script>
<script src="https://gist.github.com/sangfansh/d1728c9fb3567734b1afd2d4a65ef457.js"></script></p>

<p><code class="highlighter-rouge">NetworkManagerClient</code> starts the service by connecting the SSL client to server. Then the client starts the SSL handshake process with server. We can see that the <code class="highlighter-rouge">Client::handle_handshake()</code> function triggers the remote attestation by sending out the attestation request mentioned above if handshake is successful.</p>

<p>Upon here, <code class="highlighter-rouge">ServiceProvider</code> and Application are connected and remote attestation process has started.</p>

<hr />

<p>Now let’s examine both <code class="highlighter-rouge">incomingHandler(string, int)</code> in <code class="highlighter-rouge">MessageHandler.cpp</code> and <code class="highlighter-rouge">VerificationManager.cpp</code> to reflect the remote attestation process between SP and ISV described in the tutorial.</p>

<h3 id="summary-of-function-calls">Summary of function calls:</h3>

<p><img src="/sgx101/assets/pics/ra_summary.png" alt="ra" /></p>

<p>(Please refer to <code class="highlighter-rouge">Messages.proto</code> for message structure details.)</p>

<p>(Please refer to the two <code class="highlighter-rouge">incomingHandler</code>’s attached below for actual implementation.)</p>

<p><img src="/sgx101/assets/pics/ra_flow.png" alt="ra" />
<script src="https://gist.github.com/sangfansh/bda856ff5728ab7fff00172e6b98d456.js"></script>
<script src="https://gist.github.com/sangfansh/eadaa5c6e6d10fe43e3a562c8efd7f4f.js"></script></p>

<hr />

<h2 id="references">References:</h2>

<ol>
  <li>https://courses.cs.ut.ee/MTAT.07.022/2017_spring/uploads/Main/hiie-report-s16-17.pdf</li>
  <li>https://www.idc.ac.il/en/schools/cs/research/Documents/jackson-msc-thesis.pdf</li>
  <li>https://software.intel.com/en-us/articles/innovative-technology-for-cpu-based-attestation-and-sealing</li>
  <li>http://tce.webee.eedev.technion.ac.il/wp-content/uploads/sites/8/2015/10/SGX-for-Technion-TCE.pdf</li>
  <li>https://www.idc.ac.il/en/schools/cs/research/Documents/jackson-msc-thesis.pdf</li>
  <li>https://software.intel.com/en-us/node/702983</li>
  <li>https://software.intel.com/en-us/articles/code-sample-intel-software-guard-extensions-remote-attestation-end-to-end-example</li>
  <li>https://arxiv.org/pdf/1801.05863.pdf</li>
  <li>https://software.intel.com/en-us/forums/intel-software-guard-extensions-intel-sgx/topic/747718</li>
  <li>https://eprint.iacr.org/2007/194.pdf</li>
</ol>

</div>

    </main>

    <!-- Optional footer content -->

  </body>
</html>
